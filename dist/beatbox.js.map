{"version":3,"file":"beatbox.js","sources":["../src/beatbox.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\n\nexport interface Instrument {\n\tkey: string;\n\taudioBuffer: AudioBuffer;\n\tvolume?: number;\n}\n\nexport interface InstrumentReferenceObject {\n\tinstrument: string;\n\tvolume?: number;\n}\n\nexport type InstrumentReference = string | InstrumentReferenceObject;\n\nexport interface ScheduledSound {\n\ttime: number;\n\tduration: number;\n\tsource: AudioBufferSourceNode;\n\tstop(time?: number): void;\n\tclearTimeout: number;\n}\n\nexport type Pattern = Array<Array<InstrumentReference> | undefined>;\n\n/** A callback that receives a progress float between 0 and 1. */\nexport type BeatboxProgressCallback = (progress: number) => void;\nexport type BeatboxRecordOptions = {\n\tonProgress?: BeatboxProgressCallback;\n\tsignal?: AbortSignal;\n\tchannels?: number;\n}\n\nfunction isPlaying(beatbox: Beatbox | PlayingBeatbox): beatbox is PlayingBeatbox {\n\treturn beatbox.playing;\n}\n\ninterface PlayingBeatbox {\n\tplaying: true;\n\t_audioContext: AudioContext;\n\t_startTime: number;\n\t_referenceTime: number;\n}\n\nconst AudioContext = window.AudioContext || (window as any).webkitAudioContext;\nconst OfflineAudioContext = window.OfflineAudioContext || (window as any).webkitOfflineAudioContext;\n\nexport class Beatbox extends EventEmitter {\n\n\tstatic _cacheInterval: number = 1000;\n\tstatic _cacheLength: number = 5000;\n\tstatic _instruments: { [instr: string]: Instrument } = { };\n\tstatic _minOnBeatInterval = 100;\n\n\tplaying: boolean = false;\n\n\t_pattern: Pattern;\n\t_strokeLength: number;\n\t_repeat: boolean;\n\t_upbeat: number;\n\n\t_audioContext: BaseAudioContext | null = null;\n\t_fillCacheTimeout: number | null = null;\n\t_onBeatTimeout: number | null = null;\n\t_scheduledSounds: ScheduledSound[] = [ ];\n\n\t/** If playing, the position innside the pattern until which the cache was filled. If not playing, the position where we should start playing next time. */\n\t_position: number = 0;\n\n\t/** The this._audioContext.currentTime when the playing was started */\n\t_startTime: number | null = null;\n\n\t/** The this._audioContext.currentTime of the start of the last bar that was created by the cache (excluding upbeat) */\n\t_referenceTime: number | null = null;\n\n\t/** Last sound objects of each instrument while filling the cache */\n\t_lastInstrumentStrokes: { [instr: string]: ScheduledSound } = { };\n\n\tconstructor(pattern: Pattern, strokeLength: number, repeat: boolean, upbeat?: number) {\n\t\tsuper();\n\n\t\tthis._pattern = pattern;\n\t\tthis._strokeLength = strokeLength;\n\t\tthis._repeat = repeat;\n\t\tthis._upbeat = upbeat || 0;\n\t}\n\n\n\t/**\n\t * Add a new instrument that can be referred to by an instrument key in the pattern.\n\t * @param key {String} The key that can be used to refer to this instrument in the pattern\n\t * @param data {ArrayBuffer} An ArrayBuffer that contains the sound file\n\t */\n\tstatic async registerInstrument(key: string, data: ArrayBuffer): Promise<void> {\n\t\tconst audioContext = new AudioContext();\n\t\tconst audioBuffer = await new Promise<AudioBuffer>((resolve, reject) => {\n\t\t\taudioContext.decodeAudioData(data, resolve, reject);\n\t\t});\n\t\taudioContext.close();\n\t\tBeatbox._instruments[key] = { audioBuffer, key };\n\t}\n\n\n\tstatic unregisterInstrument(key: string): void {\n\t\tdelete Beatbox._instruments[key];\n\t}\n\n\n\t_scheduleSound(instrument: Instrument, time: number): ScheduledSound {\n\t\tconst source = this._audioContext!.createBufferSource();\n\t\tsource.buffer = instrument.audioBuffer;\n\n\t\tif (instrument.volume && instrument.volume != 1) {\n\t\t\tconst gainNode = this._audioContext!.createGain();\n\t\t\tgainNode.gain.value = instrument.volume;\n\t\t\tgainNode.connect(this._audioContext!.destination);\n\t\t\tsource.connect(gainNode);\n\t\t} else {\n\t\t\tsource.connect(this._audioContext!.destination);\n\t\t}\n\n\t\tsource.start(time);\n\n\t\tconst clear = () => {\n\t\t\tconst idx = this._scheduledSounds.indexOf(sound);\n\t\t\tif (idx != -1)\n\t\t\t\tthis._scheduledSounds.splice(idx, 1);\n\t\t};\n\n\t\tconst stop = (time?: number) => {\n\t\t\tclearTimeout(sound.clearTimeout);\n\n\t\t\tif (time != null && time > 0) {\n\t\t\t\tsource.stop(time);\n\t\t\t\tsound.clearTimeout = window.setTimeout(clear, (time - this._audioContext!.currentTime) * 1000);\n\t\t\t} else {\n\t\t\t\tsource.disconnect();\n\t\t\t\tclear();\n\t\t\t}\n\t\t};\n\n\t\tconst sound: ScheduledSound = {\n\t\t\ttime,\n\t\t\tduration: instrument.audioBuffer.duration,\n\t\t\tsource,\n\t\t\tstop,\n\t\t\tclearTimeout: window.setTimeout(clear, (time - this._audioContext!.currentTime + instrument.audioBuffer.duration) * 1000)\n\t\t};\n\t\tthis._scheduledSounds.push(sound);\n\t\treturn sound;\n\t}\n\n\n\tstatic _resolveInstrument(instr?: InstrumentReference): Instrument | null {\n\t\tif (instr == null)\n\t\t\treturn null;\n\n\t\tconst key = typeof instr == \"string\" ? instr : instr.instrument;\n\t\tif (!Beatbox._instruments[key])\n\t\t\treturn null;\n\n\t\treturn {\n\t\t\t...Beatbox._instruments[key],\n\t\t\t...(typeof instr != \"string\" && instr.volume != null ? { volume: instr.volume } : {})\n\t\t};\n\t}\n\n\n\tplay(): void {\n\t\tif(this.playing)\n\t\t\treturn;\n\n\t\tthis._audioContext = new AudioContext();\n\t\tthis.playing = true;\n\t\tthis._startTime = this._referenceTime = this._audioContext.currentTime - (this._position - this._upbeat) * this._strokeLength / 1000;\n\n\t\tthis._fillCache();\n\n\t\tconst onBeatFunc = () => {\n\t\t\tthis.emit(\"beat\", this.getPosition());\n\t\t\tlet sinceBeat = (this._audioContext!.currentTime - this._referenceTime!)*1000 % this._strokeLength;\n\t\t\tif(sinceBeat < 0)\n\t\t\t\tsinceBeat += this._strokeLength;\n\n\t\t\tthis._onBeatTimeout = window.setTimeout(onBeatFunc, Math.max(Beatbox._minOnBeatInterval, this._strokeLength - sinceBeat));\n\t\t};\n\t\tonBeatFunc();\n\n\t\tthis.emit(\"play\");\n\t}\n\n\t/**\n\t * The total length of the current pattern (including upbeat) in milliseconds.\n\t */\n\tgetLength(): number {\n\t\treturn this._pattern.reduce((v, instrs, i) => (!instrs || instrs.length == 0 ? v : Math.max(v, (\n\t\t\ti * this._strokeLength + Math.max(...instrs.map((instr) => 1000 * (Beatbox._resolveInstrument(instr)?.audioBuffer?.duration ?? 0)))\n\t\t))), this._pattern.length * this._strokeLength);\n\t}\n\n\tasync record({ channels = 2, onProgress, signal }: BeatboxRecordOptions = {}): Promise<AudioBuffer> {\n\t\tsignal?.throwIfAborted();\n\n\t\tconst audioContext = new AudioContext();\n\t\tconst sampleRate = audioContext.sampleRate;\n\t\taudioContext.close();\n\n\t\tconst offlineContext = new OfflineAudioContext(channels, Math.max(1, this.getLength() * sampleRate / 1000), sampleRate);\n\t\tthis._audioContext = offlineContext;\n\t\tthis._fillCacheInternal();\n\t\tthis._audioContext = null;\n\t\tfor (const sound of this._scheduledSounds)\n\t\t\tclearTimeout(sound.clearTimeout);\n\t\tthis._scheduledSounds = [];\n\n\t\tsignal?.throwIfAborted();\n\n\t\tif (onProgress) {\n\t\t\t(async () => {\n\t\t\t\t// Report the progress every audio second\n\t\t\t\tconst length = this.getLength();\n\t\t\t\tconst step = 1000;\n\t\t\t\tfor (let progress = step; progress < length && !signal?.aborted; progress += step) {\n\t\t\t\t\tawait offlineContext.suspend(progress / 1000);\n\t\t\t\t\tonProgress(progress / length);\n\t\t\t\t\tofflineContext.resume();\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\n\t\tconst audioBuffer = await Promise.race<AudioBuffer>([\n\t\t\tofflineContext.startRendering(),\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t// Right now we cannot abort the rendering in reaction to the abort signal, see https://github.com/WebAudio/web-audio-api/issues/2445\n\t\t\t\t// But at least we can reject the promise.\n\t\t\t\tif (signal?.aborted) {\n\t\t\t\t\treject(signal.reason);\n\t\t\t\t}\n\t\t\t\tsignal?.addEventListener(\"abort\", () => {\n\t\t\t\t\treject(signal.reason);\n\t\t\t\t});\n\t\t\t})\n\t\t]);\n\n\t\tsignal?.throwIfAborted();\n\t\tonProgress?.(1);\n\n\t\treturn audioBuffer;\n\t}\n\n\tstop(reset: boolean = false): void {\n\t\tif (!this.playing)\n\t\t\treturn;\n\n\t\tif (this._fillCacheTimeout) {\n\t\t\tclearTimeout(this._fillCacheTimeout);\n\t\t\tthis._fillCacheTimeout = null;\n\t\t}\n\n\t\tif (this._onBeatTimeout) {\n\t\t\tclearTimeout(this._onBeatTimeout);\n\t\t\tthis._onBeatTimeout = null;\n\t\t}\n\n\t\tthis._position = reset ? 0 : this.getPosition();\n\t\tthis._clearCache();\n\n\t\t(this._audioContext as AudioContext).close();\n\t\tthis._audioContext = null;\n\n\t\tthis.playing = false;\n\n\t\tthis.emit(\"stop\");\n\t}\n\n\n\tgetPosition(): number {\n\t\tif(isPlaying(this)) {\n\t\t\tlet ret = (this._audioContext.currentTime - this._referenceTime)*1000 / this._strokeLength + this._upbeat;\n\t\t\tlet min = (this._audioContext.currentTime < this._startTime) ? 0 : this._upbeat;\n\t\t\twhile(ret < min) { // In case the cache is already filling for the next repetition\n\t\t\t\tret += this._pattern.length - this._upbeat;\n\t\t\t}\n\t\t\treturn Math.floor(ret);\n\t\t} else {\n\t\t\treturn this._position;\n\t\t}\n\t}\n\n\n\tsetPosition(position: number): void {\n\t\tlet playing = this.playing;\n\t\tif(playing)\n\t\t\tthis.stop();\n\t\tthis._position = (position != null ? position : 0);\n\t\tif (playing)\n\t\t\tthis.play();\n\t}\n\n\n\tsetPattern(pattern: Pattern): void {\n\t\tthis._pattern = pattern;\n\n\t\tthis._applyChanges();\n\t}\n\n\n\tsetBeatLength(strokeLength: number): void {\n\t\tif(isPlaying(this)) {\n\t\t\t// Clear everything after the currently playing stroke. If the beat length has been increased, the clear call\n\t\t\t// in _fillWebAudioCache() would miss the old next stroke, which comes before the new next stroke.\n\t\t\tthis._clearCache(this._audioContext.currentTime+0.000001);\n\n\t\t\tlet now = (this._audioContext.currentTime - (<PlayingBeatbox> this)._referenceTime)*1000 / this._strokeLength;\n\t\t\twhile(now < 0)\n\t\t\t\tnow += this._pattern.length - this._upbeat;\n\t\t\tthis._referenceTime = this._audioContext.currentTime - now * strokeLength / 1000;\n\t\t}\n\n\t\tthis._strokeLength = strokeLength;\n\n\t\tthis._applyChanges();\n\t}\n\n\n\tsetRepeat(repeat: boolean): void {\n\t\tthis._repeat = repeat;\n\n\t\tthis._applyChanges();\n\t}\n\n\n\tsetUpbeat(upbeat: number): void {\n\t\tif (isPlaying(this)) {\n\t\t\tthis._referenceTime += (upbeat - this._upbeat) * this._strokeLength / 1000;\n\t\t}\n\t\tthis._upbeat = upbeat || 0;\n\n\t\tthis._applyChanges();\n\t}\n\n\n\t_applyChanges(): void {\n\t\tif(isPlaying(this)) {\n\t\t\tthis._position = this.getPosition()+1;\n\n\t\t\twhile(this._referenceTime > this._audioContext.currentTime) // Caching might be in a future repetition already\n\t\t\t\tthis._referenceTime -= (this._pattern.length - this._upbeat) * this._strokeLength / 1000;\n\n\t\t\tif(this._referenceTime < this._startTime)\n\t\t\t\tthis._referenceTime = this._startTime;\n\n\t\t\tthis._clearCache(this._audioContext.currentTime+0.000001);\n\t\t\tthis._fillCache();\n\t\t}\n\t}\n\n\n\t_fillCacheInternal(cacheUntil?: number): boolean {\n\t\twhile (cacheUntil == null || this._referenceTime! + (this._position - this._upbeat) * this._strokeLength / 1000 <= cacheUntil) {\n\t\t\tif(this._position >= this._pattern.length) {\n\t\t\t\tif(cacheUntil != null && this._repeat) {\n\t\t\t\t\tthis._position = this._upbeat;\n\t\t\t\t\tthis._referenceTime = this._referenceTime! + this._strokeLength * (this._pattern.length - this._upbeat) / 1000;\n\t\t\t\t} else\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst part = this._pattern[this._position];\n\t\t\tif(part) {\n\t\t\t\tfor(let strokeIdx=0; strokeIdx<part.length; strokeIdx++) {\n\t\t\t\t\tconst instr = Beatbox._resolveInstrument(part[strokeIdx]);\n\t\t\t\t\tif (instr && (instr.volume == null || instr.volume > 0)) {\n\t\t\t\t\t\tlet time = this._referenceTime! + (this._position - this._upbeat) * this._strokeLength / 1000;\n\n\t\t\t\t\t\tif(this._lastInstrumentStrokes[instr.key])\n\t\t\t\t\t\t\tthis._lastInstrumentStrokes[instr.key].stop(time);\n\n\t\t\t\t\t\tconst sound = this._scheduleSound(instr, time);\n\t\t\t\t\t\tthis._lastInstrumentStrokes[instr.key] = sound;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._position++\n\t\t}\n\n\t\treturn true;\n\t}\n\n\n\t_fillCache(): void {\n\t\tif (this._fillCacheTimeout)\n\t\t\twindow.clearTimeout(this._fillCacheTimeout);\n\n\t\tconst hasMore = this._fillCacheInternal(this._audioContext!.currentTime + Beatbox._cacheLength / 1000);\n\n\t\tif (hasMore)\n\t\t\tthis._fillCacheTimeout = window.setTimeout(() => { this._fillCache(); }, Beatbox._cacheInterval);\n\t\telse {\n\t\t\tconst endTime = Math.max(\n\t\t\t\tthis._referenceTime! * 1000 + this._strokeLength * (this._pattern.length - this._upbeat),\n\t\t\t\t...this._scheduledSounds.map((sound) => (sound.time + sound.duration) * 1000)\n\t\t\t);\n\t\t\tthis._fillCacheTimeout = window.setTimeout(() => {\n\t\t\t\tthis.stop(true);\n\t\t\t}, endTime - this._audioContext!.currentTime * 1000);\n\t\t}\n\t}\n\n\n\t_clearCache(from?: number): void {\n\t\tif (this._fillCacheTimeout)\n\t\t\tclearTimeout(this._fillCacheTimeout);\n\n\t\tfor (const sound of [...this._scheduledSounds]) {\n\t\t\tif(from == null || sound.time >= from)\n\t\t\t\tsound.stop();\n\t\t}\n\t}\n}\n\nexport default Beatbox;\n"],"names":["time"],"mappings":"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"}